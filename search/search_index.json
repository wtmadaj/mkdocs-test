{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RmmbrIt","text":""},{"location":"#your-memorys-backup-drive","title":"Your memory's backup drive.","text":"<p>Store all the things you need to remember in one place.</p> <p>Find yourself forgetting where you put something? Can't remember the thing you need to buy that you only need a few times a year? RmmbrIt can solve the problem. Some common examples of things we've forgotten: - Furnace filter size, brand, and/or quality - Car taillight I need to buy. And headlight. - Light bulb type my kitchen lights use. - Location of stored items (closet, crawlspace, storage unit, attic)</p> <p>Did you take a picture of the thing but can't find it? Buried alongside thousands of other pictures? You can add images too!</p> <p>Add the things you need to remember and easily find them later. Add text, pictures, descriptions, tags, whatever you need. All searchable when you need to remember it.</p>"},{"location":"#ideas","title":"Ideas","text":""},{"location":"#home-screen","title":"Home Screen","text":"<p>Tabs or buttons (top or bottom nav) to view by: - All items - Categories (tags)</p>"},{"location":"#splash-screen","title":"Splash Screen","text":"<p>GIF / graphic / video of \"Remember It\" sliding together to be \"RmmbrIt\" as splash screen. - CSS Transitions - CSS Animations - FreeCodeCamp Examples</p>"},{"location":"#company-names","title":"Company Names","text":"<p>Parent Company: 3-Titans.com</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Give the item a title</li> <li>Add categories (auto, home, storage, purpose)</li> <li>Add an image (or don't)</li> <li>Save it</li> <li>Forget about it</li> <li>When you need to remember it, open RmmbrIt</li> <li>Find it. Or search by the name or category to find it</li> </ol> <p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Database/database-design/","title":"Database Design","text":"<p>The choice of database type depends on various factors including scalability requirements, performance needs, development preferences, and budget constraints. Here are some commonly used database types that could be suitable for storing user notes and attachments:</p>"},{"location":"Database/database-design/#relational-databases-sql","title":"Relational Databases (SQL):","text":"<ul> <li>MySQL: A popular open-source relational database management system (RDBMS) known for its reliability, performance, and ease of use. It's well-suited for applications with structured data like user notes and attachments.</li> <li>PostgreSQL: Another open-source RDBMS known for its advanced features, extensibility, and strong support for SQL standards. It offers features like JSONB data type for storing semi-structured data, which could be useful for attachments.</li> </ul>"},{"location":"Database/database-design/#nosql-databases","title":"NoSQL Databases:","text":"<ul> <li>MongoDB: A popular document-oriented NoSQL database that stores data in flexible, JSON-like documents. It's suitable for applications with semi-structured data like attachments, especially if you need flexibility in schema design or if your data is expected to grow rapidly.</li> <li>Amazon DynamoDB: A fully managed NoSQL database service provided by AWS. It offers high scalability, performance, and reliability, making it suitable for applications with unpredictable workloads or high traffic volumes.</li> </ul>"},{"location":"Database/database-design/#cloud-based-solutions","title":"Cloud-based Solutions:","text":"<ul> <li>Firebase: Google's mobile and web application development platform that offers a real-time database (Firebase Realtime Database) and a cloud-hosted NoSQL database (Cloud Firestore). These are suitable for building real-time collaborative applications like note-taking apps with features such as synchronization across devices.</li> <li>AWS RDS (Relational Database Service): A managed relational database service provided by AWS that supports various database engines including MySQL, PostgreSQL, and others. It simplifies database administration tasks like provisioning, patching, and backups.</li> </ul>"},{"location":"Database/database-design/#hybrid-solutions","title":"Hybrid Solutions:","text":"<ul> <li>CockroachDB: A distributed SQL database that offers the scalability of NoSQL databases while providing ACID transactions and SQL support like traditional RDBMS. It's suitable for applications that require horizontal scalability and strong consistency guarantees.</li> </ul>"},{"location":"Database/database-design/#custom-solutions","title":"Custom Solutions:","text":"<p>Depending on your specific requirements and constraints, you might opt for a custom database solution built on top of technologies like Apache Cassandra for distributed storage, Apache Kafka for event sourcing, or a combination of different database types tailored to your application's needs.</p> <p>Consider factors like data consistency, scalability, ease of development, vendor lock-in, and cost when choosing the best database type for your application. It's also important to evaluate the ecosystem, community support, and available tools for each database type to ensure smooth development and maintenance of your application.</p>"},{"location":"Database/mysql-db-design/","title":"MySQL Database Design","text":""},{"location":"Database/mysql-db-design/#description","title":"Description","text":""},{"location":"Database/mysql-db-design/#tables","title":"Tables","text":""},{"location":"Database/mysql-db-design/#users-table","title":"Users Table","text":"<ul> <li>user_id (Primary Key): UUID. A unique identifier for each user.</li> <li>username or email: Unique identifier for login.</li> <li>Other user-related information like name, profile picture, etc.</li> </ul>"},{"location":"Database/mysql-db-design/#notes-table","title":"Notes Table","text":"<ul> <li>note_id (Primary Key): UUID. A unique identifier for each note.</li> <li>user_id (Foreign Key): References the <code>user_id</code> in the Users table to establish a relationship between users and their notes.</li> <li>title: Title of the note.</li> <li>content: The actual content of the note.</li> <li>tag_count: number of tags associated with the note.</li> <li>attachment_count: If using attachment table.</li> <li>created_at: Timestamp indicating when the note was created.</li> <li>updated_at: Timestamp indicating when the note was last updated.</li> </ul>"},{"location":"Database/mysql-db-design/#attachments-table","title":"Attachments Table","text":"<ul> <li>attachment_id (Primary Key): A unique identifier for each attachment.</li> <li>note_id (Foreign Key): References the <code>note_id</code> in the Notes table to associate attachments with specific notes.</li> <li>file_name: Name of the attached file.</li> <li>file_path: Path to the stored file on your server or cloud storage.</li> <li>file_type: MIME type or file extension to identify the type of file.</li> <li>created_at: Timestamp indicating when the attachment was added.</li> </ul>"},{"location":"Database/mysql-db-design/#attachments-application-logic","title":"Attachments Application Logic","text":"<p>When a user adds an attachment to a note, your application logic should: 1. Store the file on your server or cloud storage. 2. Create a record in the Attachments table with information about the attachment and its association with the corresponding note. 3. Update the attachment_count column in the Notes table for the respective note. 4. When displaying notes, retrieve attachments associated with each note and provide appropriate links or previews for users to access them.</p> <p>Security Considerations: Ensure proper validation and sanitization of file uploads to prevent security vulnerabilities like file injection attacks. Implement access controls to ensure that users can only access attachments associated with their own notes.</p> <p>Scalability and Performance: Consider scalability and performance implications, especially if your application allows large file uploads. You may need to optimize storage and retrieval mechanisms, and possibly implement caching strategies for frequently accessed attachments.</p>"},{"location":"Database/mysql-db-design/#tags-table","title":"Tags Table","text":"<ul> <li>tag_id (Primary Key): UUID. A unique identifier for each tag.</li> <li>tag_name: The name of the tag.</li> <li>Optionally, add additional columns such as created_at to track when the tag was created.</li> </ul>"},{"location":"Database/mysql-db-design/#notetags-table","title":"NoteTags Table","text":"<p>Create an intermediate table to establish a many-to-many relationship between notes and tags.</p> <ul> <li>note_id (Foreign Key): References the note_id in the Notes table.</li> <li>tag_id (Foreign Key): References the tag_id in the Tags table.</li> <li>Optionally, additional columns like created_at to track when the tag was added to the note.</li> </ul>"},{"location":"Database/mysql-db-design/#tags-application-logic","title":"Tags Application Logic","text":"<p>When a user adds tags to a note, your application logic should: 1. Create records in the Tags table for any new tags that don't already exist. 2. Create records in the NoteTags table to establish associations between the note and the tags. 3. Update the tag_count column in the Notes table for the respective note. 4. When displaying notes, retrieve tags associated with each note and display them accordingly.</p>"},{"location":"Database/mysql-db-design/#search-and-filter-functionality","title":"Search and Filter Functionality","text":"<p>Implement search and filter functionality based on tags, allowing users to easily find notes with specific tags.</p>"},{"location":"Database/mysql-db-design/#ensure-data-integrity","title":"Ensure Data Integrity","text":"<p>Implement constraints or validations to ensure that tags are unique and properly formatted. Implement cascading deletes or updates to maintain data integrity when notes or tags are deleted or modified.</p>"},{"location":"Database/mysql-db-design/#attachments-as-separate-table-attachments-within-notes-table","title":"Attachments as separate table || Attachments within Notes Table","text":"<p>Using a separate attachments table instead of inserting attachments directly into the notes table offers several benefits:</p> <ul> <li>Normalization: Separating attachments into their own table follows the principles of database normalization, specifically the Third Normal Form (3NF). Each table in the database represents a single entity (in this case, either notes or attachments), which reduces data redundancy and ensures efficient storage.</li> <li>Scalability: Storing attachments in a separate table can improve the scalability of your database. If notes can have multiple attachments, storing them directly in the notes table could lead to bloating and increased storage requirements as the number of attachments grows. With a separate table, you can more efficiently manage and scale the storage of attachments independently of notes.</li> <li>Flexibility: Separating attachments into their own table allows for more flexibility in managing attachments. You can implement features like versioning, access controls, and different storage mechanisms (e.g., local file system, cloud storage) more effectively when attachments are stored separately.</li> <li>Performance: Retrieving notes without attachments can be faster when attachments are stored in a separate table, especially if attachments are large or if there are many of them. This separation allows the database to optimize queries for retrieving notes without having to deal with the overhead of fetching potentially large binary data.</li> <li>Security: Storing attachments separately can enhance security by allowing you to implement different access controls and encryption mechanisms specifically tailored to attachment storage. It can also help mitigate risks associated with SQL injection attacks targeting attachment data.</li> </ul> <p>In summary, using a separate attachments table provides better data organization, scalability, flexibility, performance, and security compared to storing attachments directly within the notes table.</p>"},{"location":"Database/mysql-db-design/#tags-as-separate-table-tags-within-notes-table","title":"Tags as separate table || Tags within Notes Table","text":"<p>If tags are an enumeration, meaning they have a predefined set of values and don't change frequently, you might wonder about the necessity of using separate Tag and NoteTag tables. While it might seem simpler to just have a column for tags directly within the Notes table, there are still benefits to using separate tables:</p> <ul> <li>Consistency and Data Integrity: By using a separate Tag table, you enforce consistency in your data. This ensures that all tags are uniformly represented and eliminates the risk of typographical errors or inconsistencies in tag names. It also facilitates easier management if changes to the tag set are required in the future.</li> <li>Scalability and Flexibility: Even if tags are currently an enumeration, future requirements might change. For example, you might want to add additional attributes to tags (e.g., descriptions, colors) or allow users to create custom tags. Using a separate Tag table provides flexibility to accommodate such changes without needing to modify the structure of the Notes table.</li> <li>Normalization: Using separate tables follows the principles of database normalization, specifically the Third Normal Form (3NF). Each table represents a distinct entity (tags and notes), which helps reduce data redundancy and improves database efficiency.</li> <li>Efficient Queries: Separating tags into their own table allows for more efficient querying, especially if you need to perform operations like searching for notes based on tags or aggregating data by tag. It also facilitates easier maintenance and optimization of database indexes for tag-related queries.</li> <li>Integration with Other Features: Having a separate Tag table provides a foundation for implementing additional features related to tags, such as tag-based search, tag suggestions, or tag analytics. It also makes it easier to integrate with external systems or APIs that might use standardized tag formats.</li> </ul> <p>While using separate Tag and NoteTag tables might introduce some additional complexity compared to storing tags directly within the Notes table, the benefits in terms of data consistency, scalability, and flexibility often outweigh the overhead. Additionally, modern database systems are well-equipped to efficiently handle joins between tables, making the performance impact of using separate tables minimal in most cases.</p>"},{"location":"Database/mysql-db-design/#schemas","title":"Schemas","text":""},{"location":"Database/nosql-db-design/","title":"NoSQL Database Design","text":""},{"location":"Database/nosql-db-design/#description","title":"Description","text":"<p>Firestore is a flexible, scalable database for mobile, web, and server development. Data is structured into Collections and Documents.</p>"},{"location":"Database/nosql-db-design/#collections","title":"Collections","text":""},{"location":"Database/nosql-db-design/#users-collection","title":"Users Collection","text":"<ul> <li>Each document represents a user.</li> <li>Document ID: user_id (or automatically generated by Firestore)</li> </ul> <pre><code>{\n  \"user_id\": \"user_id\",\n  \"username\": \"user_name\",\n  \"email\": \"user_email\",\n  \"password\": \"encrypted_password\",\n  \"profile_picture\": \"profile_picture_url\",\n  \"created_at\": \"timestamp\",\n  \"updated_at\": \"timestamp\"\n}\n</code></pre>"},{"location":"Database/nosql-db-design/#notes-collection","title":"Notes Collection","text":"<ul> <li>Each document represents a note.</li> <li>Document ID: note_id (or automatically generated by Firestore)   You can create a subcollection for each user's notes under the Users collection, or have a top-level Notes collection with user_id as a field.</li> </ul>"},{"location":"Database/nosql-db-design/#option-1-top-level-notes-collection","title":"Option 1 Top-Level Notes Collection","text":"<pre><code>{\n  \"note_id\": \"note_id\",\n  \"user_id\": \"user_id\",\n  \"title\": \"note_title\",\n  \"content\": \"note_content\",\n  \"tags\": [\"tag1\", \"tag2\", \"tag3\"],\n  \"attachments\": [\n    {\n      \"file_name\": \"file_name\",\n      \"file_path\": \"file_path\",\n      \"file_type\": \"file_mime_type\",\n      \"created_at\": \"timestamp\"\n    }\n  ],\n  \"created_at\": \"timestamp\",\n  \"updated_at\": \"timestamp\"\n}\n</code></pre>"},{"location":"Database/nosql-db-design/#option-2-subcollection-under-users","title":"Option 2: SubCollection Under Users","text":"<pre><code>{\n  \"user_id\": \"user_id\",\n  \"username\": \"user_name\",\n  \"email\": \"user_email\",\n  \"password\": \"encrypted_password\",\n  \"profile_picture\": \"profile_picture_url\",\n  \"created_at\": \"timestamp\",\n  \"updated_at\": \"timestamp\",\n  \"notes\": {\n    \"note_id\": {\n      \"title\": \"note_title\",\n      \"content\": \"note_content\",\n      \"tags\": [\"tag1\", \"tag2\", \"tag3\"],\n      \"attachments\": [\n        {\n          \"file_name\": \"file_name\",\n          \"file_path\": \"file_path\",\n          \"file_type\": \"file_mime_type\",\n          \"created_at\": \"timestamp\"\n        }\n      ],\n      \"created_at\": \"timestamp\",\n      \"updated_at\": \"timestamp\"\n    }\n  }\n}\n</code></pre>"},{"location":"Database/nosql-db-design/#tags-collection","title":"Tags Collection","text":"<p>Tip</p> <p>Use this approach if managing tags centrally.</p> <p>Question</p> <p>How to approach if NOT wanting to manage centrally?</p> <ul> <li>Each document represents a tag.</li> <li>Document ID: tag_id (or automatically generated by Firestore)</li> </ul> <pre><code>{\n  \"tag_id\": \"tag_id\",\n  \"tag_name\": \"tag_name\",\n  \"created_at\": \"timestamp\"\n}\n</code></pre>"},{"location":"Database/nosql-db-design/#considerations-for-firestore","title":"Considerations for Firestore","text":""},{"location":"Database/nosql-db-design/#data-structuring","title":"Data Structuring:","text":"<p>Firestore is designed to work well with hierarchical data, making it easy to structure data with collections and subcollections. Use subcollections to naturally group related data (e.g., user notes under a user document). Denormalization is common in Firestore to reduce the number of reads. For example, you might duplicate some user information in the notes collection for faster access.</p>"},{"location":"Database/nosql-db-design/#indexing-and-querying","title":"Indexing and Querying:","text":"<p>Firestore automatically indexes all fields, but complex queries (e.g., compound queries) may require creating custom indexes in the Firestore console. Use Firestore's powerful querying capabilities to retrieve notes by user, filter by tags, or search for specific content.</p>"},{"location":"Database/nosql-db-design/#real-time-updates","title":"Real-time Updates:","text":"<p>Firestore supports real-time data synchronization. Use Firestore's real-time listeners to keep your application updated with the latest data without manual refreshes.</p>"},{"location":"Database/nosql-db-design/#security-rules","title":"Security Rules:","text":"<p>Implement Firestore security rules to control access to your data. Ensure users can only read and write their own notes and attachments.</p>"},{"location":"Database/nosql-db-design/#scalability","title":"Scalability:","text":"<p>Firestore is designed to scale automatically. As your application grows, Firestore handles the increased load without requiring manual intervention.</p>"},{"location":"Database/nosql-db-design/#example-adding-a-note-with-attachments-and-tags","title":"Example: Adding a Note with Attachments and Tags","text":"<p>When a user adds a note with attachments and tags, your application logic would:</p> <ol> <li>Create a document in the Notes collection or the user's notes subcollection.</li> <li>Add fields for title, content, tags, and attachments.</li> <li>If using a central Tags collection, ensure tags exist or create new tag documents.</li> </ol>"},{"location":"Database/queries/","title":"Queries","text":""},{"location":"Database/queries/#read-queries","title":"Read Queries","text":""},{"location":"Database/queries/#getallnotes","title":"GetAllNotes","text":"<ul> <li>My Rmmbrits</li> <li>MyRmmbritsListView</li> </ul> <p>Used to display all RmmbrIts on the home page</p> <pre><code>Select * from Notes\n</code></pre>"},{"location":"Database/queries/#getnotetags","title":"GetNoteTags","text":"<pre><code>Select * from NoteTags where\nnote_id = '${noteId}';\n</code></pre>"},{"location":"Database/queries/#getalltags","title":"GetAllTags","text":"<ul> <li>Add New RmmbrIt</li> <li>AllTagsChoiceChips</li> </ul> <pre><code>Select * from Tags ORDER BY tag_name;\n</code></pre>"},{"location":"Database/queries/#getnote","title":"GetNote","text":"<pre><code>Select * from Notes where note_id = '${noteId}'\n</code></pre>"},{"location":"Database/queries/#gettagsfornote","title":"GetTagsForNote","text":"<ul> <li>My Rmmbrits</li> <li>TagsRow GridView</li> <li>Edit Rmmbrit</li> <li>Container</li> </ul> <pre><code>SELECT *\nFROM Tags t\nJOIN NoteTags nt ON t.tag_id = nt.tag_id\nWHERE nt.note_id = '${noteId}' ORDER BY tag_name;\n</code></pre>"},{"location":"Database/queries/#getuserinfo","title":"GetUserInfo","text":"<pre><code>Select * from Users where user_id = 'new-user-1';\n</code></pre>"},{"location":"Database/queries/#getattachmentsfornote","title":"GetAttachmentsForNote","text":"<pre><code>SELECT *\nFROM Attachments\nWHERE note_id = '${noteId}';\n</code></pre>"},{"location":"Database/queries/#searchnotesandtags","title":"SearchNotesAndTags","text":"<p>Deprecated</p> <pre><code>SELECT *\nFROM Notes n\nLEFT JOIN NoteTags nt ON n.note_id = nt.note_id\nLEFT JOIN Tags t ON nt.tag_id = t.tag_id\nWHERE n.title LIKE '${search}%'\n   OR n.content LIKE '${search}%'\n   OR t.tag_name LIKE '${search}%';\n</code></pre>"},{"location":"Database/queries/#gettagidfromname","title":"GetTagIdFromName","text":"<pre><code>SELECT * FROM Tags WHERE tag_name = '${tagName}';\n</code></pre>"},{"location":"Database/queries/#searchnotesandtagsv2","title":"SearchNotesAndTagsV2","text":"<p>Deprecated</p> <pre><code>SELECT *\nFROM Notes n\nWHERE n.title LIKE '%${search}%'\n   OR n.content LIKE '%${search}%'\n   OR NoteTags.tag_name LIKE '%${search}%';\n</code></pre>"},{"location":"Database/queries/#searchtags","title":"SearchTags","text":"<ul> <li>Tags</li> <li>SearchTagsGridView</li> </ul> <p>Searches tag_name based on search query and returns results</p> <pre><code>SELECT *\nFROM Tags \nWHERE tag_name LIKE '%${search}%' ORDER BY tag_name;\n</code></pre>"},{"location":"Database/queries/#searchnotesandtagsv3","title":"SearchNotesAndTagsV3","text":"<pre><code>SELECT *\nFROM Notes\nWHERE title LIKE '%${search}%'\n   OR content LIKE '%${search}%'\n   OR tags_column LIKE '%${search}%';\n</code></pre>"},{"location":"Database/queries/#update-queries","title":"Update Queries","text":""},{"location":"Database/queries/#addnote","title":"AddNote","text":"<ul> <li>My Rmmbrits</li> <li>FloatingActionButton</li> <li>Action Flow</li> </ul> <p>Creates a new RmmbrIt when the action button is pressed on My RmmbrIts page. This is done in order to prevent attachment null pointers when the AddNewRmmbrit widget loads. <pre><code>INSERT INTO Notes (note_id, title, content, created_at, updated_at, tags_column) \nVALUES (\n  '${noteId}',\n  '${title}', \n  '${content}', \n  date(), \n  date(),\n  '${combinedTags}'\n );\n</code></pre></p>"},{"location":"Database/queries/#deletenote","title":"DeleteNote","text":"<pre><code>DELETE FROM Notes WHERE note_id = '${id}';\nDELETE FROM Attachments WHERE note_id = '${id}';\nDELETE FROM NoteTags WHERE note_id = '${id}';\n</code></pre>"},{"location":"Database/queries/#updatenote","title":"UpdateNote","text":"<pre><code>UPDATE Notes\nSET \n    title = '${title}',\n    content = '${content}',\n    updated_at = date(),\n    tags_column = '${combinedTags}'\nWHERE note_id = '${noteId}';\n</code></pre>"},{"location":"Database/queries/#addtagsfornewnote","title":"AddTagsForNewNote","text":"<pre><code>INSERT INTO NoteTags (note_id, tag_id)\nVALUES ('${noteId}', '${tagId}');\n</code></pre>"},{"location":"Database/queries/#updatetagsforexistingnote","title":"UpdateTagsForExistingNote","text":"<pre><code>DELETE FROM NoteTags\nWHERE note_id = '${noteId}';\nINSERT INTO NoteTags (note_id, tag_id)\nVALUES ('${noteId}', '${tagId}');\n</code></pre>"},{"location":"Database/queries/#updatetag","title":"UpdateTag","text":"<p><pre><code>UPDATE Tags\nSET \n    tag_name = '${tagName}'\nWHERE tag_id = '${tagId}';\n</code></pre> - Need to update the tags_column in Notes table</p>"},{"location":"Database/queries/#deletetag","title":"DeleteTag","text":"<p><pre><code>DELETE FROM Tags where tag_id='${tagId}';\nDELETE FROM NoteTags WHERE tag_id='${tagId}';\n</code></pre> - Need to update the tags_column in Notes table</p>"},{"location":"Database/queries/#createnewtag","title":"CreateNewTag","text":"<pre><code>INSERT into Tags (tag_name, tag_id) \nVALUES ('${tagName}', '${tagId}');\n</code></pre>"},{"location":"Database/queries/#deleteattachment","title":"DeleteAttachment","text":"<pre><code>Delete from Attachments where attachment_id = '${attachmentId}';\n</code></pre>"},{"location":"Database/queries/#addattachment","title":"AddAttachment","text":"<pre><code>INSERT into Attachments (attachment_id, attachment, note_id)\nVALUES (\n  '${attachmentId}',\n  '${attachment}',\n  '${noteId}'\n  );\n</code></pre>"},{"location":"Database/queries/#updateuserinfo","title":"UpdateUserInfo","text":"<pre><code>UPDATE Users\nSET \n    display_name = '${displayName}',\n    email = '${email}',\n</code></pre>"},{"location":"Database/queries/#addtempnote","title":"AddTempNote","text":"<pre><code>INSERT INTO Notes (note_id, created_at) \nVALUES (\n  '${noteId}',\n  date()\n );\n</code></pre>"},{"location":"Database/queries/#deletetempnote","title":"DeleteTempNote","text":"<pre><code>DELETE FROM Notes WHERE note_id = '${noteId}'; \n</code></pre>"},{"location":"Database/queries/#testaddnotefromtagname","title":"TestAddNoteFromTagName","text":"<pre><code>INSERT OR IGNORE INTO NoteTags (note_id, tag_id)\nVALUES ('${noteId}', (SELECT tag_id FROM Tags WHERE tag_name = '${tagName}'));\n</code></pre>"},{"location":"Database/queries/#deletealltagsfornote","title":"DeleteAllTagsForNote","text":"<pre><code>DELETE FROM NoteTags WHERE note_id = '${noteId}';\n</code></pre>"}]}