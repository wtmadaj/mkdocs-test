# NoSQL Database Design
## Description
Firestore is a flexible, scalable database for mobile, web, and server development. Data is structured into Collections and Documents.

## Collections
### Users Collection

- Each document represents a user.
- Document ID: user_id (or automatically generated by Firestore)

```json
{
  "user_id": "user_id",
  "username": "user_name",
  "email": "user_email",
  "password": "encrypted_password",
  "profile_picture": "profile_picture_url",
  "created_at": "timestamp",
  "updated_at": "timestamp"
}
```

### Notes Collection

- Each document represents a note.
- Document ID: note_id (or automatically generated by Firestore)
  You can create a subcollection for each user's notes under the Users collection, or have a top-level Notes collection with user_id as a field.

#### Option 1 Top-Level Notes Collection
```json
{
  "note_id": "note_id",
  "user_id": "user_id",
  "title": "note_title",
  "content": "note_content",
  "tags": ["tag1", "tag2", "tag3"],
  "attachments": [
    {
      "file_name": "file_name",
      "file_path": "file_path",
      "file_type": "file_mime_type",
      "created_at": "timestamp"
    }
  ],
  "created_at": "timestamp",
  "updated_at": "timestamp"
}
```

#### Option 2: SubCollection Under Users

```json
{
  "user_id": "user_id",
  "username": "user_name",
  "email": "user_email",
  "password": "encrypted_password",
  "profile_picture": "profile_picture_url",
  "created_at": "timestamp",
  "updated_at": "timestamp",
  "notes": {
    "note_id": {
      "title": "note_title",
      "content": "note_content",
      "tags": ["tag1", "tag2", "tag3"],
      "attachments": [
        {
          "file_name": "file_name",
          "file_path": "file_path",
          "file_type": "file_mime_type",
          "created_at": "timestamp"
        }
      ],
      "created_at": "timestamp",
      "updated_at": "timestamp"
    }
  }
}
```

### Tags Collection

!!! tip
    Use this approach if managing tags centrally.

!!! question
    How to approach if NOT wanting to manage centrally?

- Each document represents a tag.
- Document ID: tag_id (or automatically generated by Firestore)

```json
{
  "tag_id": "tag_id",
  "tag_name": "tag_name",
  "created_at": "timestamp"
}
```

### Considerations for Firestore
#### Data Structuring:

Firestore is designed to work well with hierarchical data, making it easy to structure data with collections and subcollections. Use subcollections to naturally group related data (e.g., user notes under a user document).
Denormalization is common in Firestore to reduce the number of reads. For example, you might duplicate some user information in the notes collection for faster access.

#### Indexing and Querying:

Firestore automatically indexes all fields, but complex queries (e.g., compound queries) may require creating custom indexes in the Firestore console.
Use Firestore's powerful querying capabilities to retrieve notes by user, filter by tags, or search for specific content.

#### Real-time Updates:

Firestore supports real-time data synchronization. Use Firestore's real-time listeners to keep your application updated with the latest data without manual refreshes.
#### Security Rules:

Implement Firestore security rules to control access to your data. Ensure users can only read and write their own notes and attachments.
#### Scalability:

Firestore is designed to scale automatically. As your application grows, Firestore handles the increased load without requiring manual intervention.

### Example: Adding a Note with Attachments and Tags
When a user adds a note with attachments and tags, your application logic would:

1. Create a document in the Notes collection or the user's notes subcollection.
2. Add fields for title, content, tags, and attachments.
3. If using a central Tags collection, ensure tags exist or create new tag documents.

